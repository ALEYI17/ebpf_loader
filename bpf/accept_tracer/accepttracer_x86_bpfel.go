// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64

package accepttracer

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type AccepttracerSocketEventT struct {
	Pid              uint32
	Uid              uint32
	Gid              uint32
	_                [4]byte
	CgroupId         uint64
	Ppid             uint32
	Comm             [150]uint8
	CgroupName       [150]uint8
	UserPid          uint32
	UserPpid         uint32
	TimestampNsEnter uint64
	TimestampNsExit  uint64
	LatencyNs        uint64
	Ret              int64
	SaFamily         uint16
	_                [2]byte
	SaddrV4          uint32
	DaddrV4          uint32
	SaddrV6          [16]uint8
	DaddrV6          [16]uint8
	Sport            uint16
	Dport            uint16
}

// LoadAccepttracer returns the embedded CollectionSpec for Accepttracer.
func LoadAccepttracer() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_AccepttracerBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load Accepttracer: %w", err)
	}

	return spec, err
}

// LoadAccepttracerObjects loads Accepttracer and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*AccepttracerObjects
//	*AccepttracerPrograms
//	*AccepttracerMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadAccepttracerObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadAccepttracer()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// AccepttracerSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type AccepttracerSpecs struct {
	AccepttracerProgramSpecs
	AccepttracerMapSpecs
	AccepttracerVariableSpecs
}

// AccepttracerProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type AccepttracerProgramSpecs struct {
	HandleAcceptEnter *ebpf.ProgramSpec `ebpf:"handle_accept_enter"`
	HandleAcceptExit  *ebpf.ProgramSpec `ebpf:"handle_accept_exit"`
}

// AccepttracerMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type AccepttracerMapSpecs struct {
	AcceptEvents   *ebpf.MapSpec `ebpf:"accept_events"`
	AcceptEventsTs *ebpf.MapSpec `ebpf:"accept_events_ts"`
}

// AccepttracerVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type AccepttracerVariableSpecs struct {
	Unused *ebpf.VariableSpec `ebpf:"unused"`
}

// AccepttracerObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadAccepttracerObjects or ebpf.CollectionSpec.LoadAndAssign.
type AccepttracerObjects struct {
	AccepttracerPrograms
	AccepttracerMaps
	AccepttracerVariables
}

func (o *AccepttracerObjects) Close() error {
	return _AccepttracerClose(
		&o.AccepttracerPrograms,
		&o.AccepttracerMaps,
	)
}

// AccepttracerMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadAccepttracerObjects or ebpf.CollectionSpec.LoadAndAssign.
type AccepttracerMaps struct {
	AcceptEvents   *ebpf.Map `ebpf:"accept_events"`
	AcceptEventsTs *ebpf.Map `ebpf:"accept_events_ts"`
}

func (m *AccepttracerMaps) Close() error {
	return _AccepttracerClose(
		m.AcceptEvents,
		m.AcceptEventsTs,
	)
}

// AccepttracerVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to LoadAccepttracerObjects or ebpf.CollectionSpec.LoadAndAssign.
type AccepttracerVariables struct {
	Unused *ebpf.Variable `ebpf:"unused"`
}

// AccepttracerPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadAccepttracerObjects or ebpf.CollectionSpec.LoadAndAssign.
type AccepttracerPrograms struct {
	HandleAcceptEnter *ebpf.Program `ebpf:"handle_accept_enter"`
	HandleAcceptExit  *ebpf.Program `ebpf:"handle_accept_exit"`
}

func (p *AccepttracerPrograms) Close() error {
	return _AccepttracerClose(
		p.HandleAcceptEnter,
		p.HandleAcceptExit,
	)
}

func _AccepttracerClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed accepttracer_x86_bpfel.o
var _AccepttracerBytes []byte
